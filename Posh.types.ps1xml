<?xml version="1.0" encoding="utf-16"?>
<!-- Generated with EZOut 2.0: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>Posh</Name>
    <Members>
      <AliasProperty>
        <Name>Error</Name>
        <ReferencedMemberName>Errors</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Profile</Name>
        <ReferencedMemberName>Profiles</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Recommend</Name>
        <ReferencedMemberName>Recommends</ReferencedMemberName>
      </AliasProperty>
      <ScriptProperty>
        <Name>Errors</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Returns all errors
.DESCRIPTION
    Returns all errors from the current session
.EXAMPLE
    $Posh.Errors
#&gt;
$global:Error
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ExecutionContext</Name>
        <GetScriptBlock>
                        $global:ExecutionContext
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>History</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the PowerShell History
.DESCRIPTION
    Gets the history of commands run in this PowerShell session.
.EXAMPLE
    $posh.History
.LINK
    Get-History
#&gt;
Get-History
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Host</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the PowerShell Host
.DESCRIPTION
    Gets the current PowerShell Host
.EXAMPLE
    $posh.Host

#&gt;
$global:host
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Jobs</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets PowerShell Jobs
.DESCRIPTION
    Gets PowerShell Background Jobs
.EXAMPLE
    $posh.Jobs
.Link
    Get-Job
.Link
    Start-Job
#&gt;
Get-Job
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Modules</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the loaded modules
.DESCRIPTION
    Gets the PowerShell modules loaded in the current session.
#&gt;
Get-Module
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Presets</Name>
        <GetScriptBlock>
                        # Get-Module 
$moduleRoots = Get-Module | Split-Path | Select-Object -Unique


foreach ($extensionFile in $posh.Commands.FindExtensions.Invoke(@(
        $posh
        $moduleRoots
    ))
) {
    if ($extensionFile.pstypenames -contains 'Posh.Preset.Command') {
        $extensionFile
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Process</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the PowerShell Process
.DESCRIPTION
    Gets the process currently hosting PowerShell
.EXAMPLE
    $posh.Process
#&gt;
Get-Process -id $PID
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Profiles</Name>
        <GetScriptBlock>
                        $profile
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Recommends</Name>
        <GetScriptBlock>
                        foreach ($module in $posh.Modules) {
    $module.Recommendation
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Runspace</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the PowerShell Runspaces
.DESCRIPTION
    Gets the current PowerShell Runspace.
.EXAMPLE
    $posh.Runspace
#&gt;
$host.Runspace
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Commands</Name>
    <Members>
      <MemberSet>
        <Name>PSStandardMembers</Name>
        <Members>
          <PropertySet>
            <Name>DefaultDisplayPropertySet</Name>
            <ReferencedProperties>
              <Name>Count</Name>
              <Name>AliasCount</Name>
              <Name>ApplicationCount</Name>
              <Name>CmdletCount</Name>
              <Name>FunctionCount</Name>
            </ReferencedProperties>
          </PropertySet>
        </Members>
      </MemberSet>
      <AliasProperty>
        <Name>Aliases</Name>
        <ReferencedMemberName>Alias</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Applications</Name>
        <ReferencedMemberName>Application</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Cmdlets</Name>
        <ReferencedMemberName>Cmdlet</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Functions</Name>
        <ReferencedMemberName>Function</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>FindExtensions</Name>
        <Script>
                        &lt;#
.SYNOPSIS

.DESCRIPTION

.EXAMPLE
    $posh.Commands.FindExtensions($posh, "$pwd")
#&gt;
$targetModules = @()
$targetPaths = @()
$loadedModules = Get-Module
foreach ($arg in $args) {
    if ($arg -is [Management.Automation.PSModuleInfo]) {
        $targetModules += $arg
    }
    elseif ($arg -is [IO.FileInfo] -or $arg -is [IO.DirectoryInfo]) {
        $targetPaths += $arg
    } 
    elseif ($arg -is [Management.Automation.PathInfo]) {
        $targetPaths += "$arg"
    }
    elseif ($arg -is [string]) {
        $argIsModule = 
            foreach ($module in $loadedModules) { if ($module.Name -like $arg) { $module}}
        if ($argIsModule) {
            $targetModules += $argIsModule
        } elseif (Test-Path $arg) {
            $targetPaths += $arg
        }
        
    }
}

if (-not $targetModules) { $targetModules = $posh.Modules}
$Splat = @{}
if ($targetPaths) {
    $Splat.FilePath = $targetPaths
}
foreach ($module in $targetModules) {
    # Aspect.ModuleExtendedCommand
    &amp; { 
        &lt;#
        .SYNOPSIS
            Returns a module's extended commands
        .DESCRIPTION
            Returns the commands or scripts in a module that match the module command pattern.
            Each returned script will be decorated with the typename(s) that match,
            so that the extended commands can be augmented by the extended types system.
        .LINK
            Aspect.ModuleCommandPattern
        .EXAMPLE
            Aspect.ModuleExtensionCommand -Module PipeScript # Should -BeOfType ([Management.Automation.CommandInfo])
        #&gt;
        [Alias('Aspect.ModuleExtendedCommand')]
        param(
        # The name of a module, or a module info object.
        [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
        [ValidateScript({
        $validTypeList = [System.String],[System.Management.Automation.PSModuleInfo]
        $thisType = $_.GetType()
        $IsTypeOk =
            $(@( foreach ($validType in $validTypeList) {
                if ($_ -as $validType) {
                    $true;break
                }
            }))
        if (-not $isTypeOk) {
            throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','psmoduleinfo'."
        }
        return $true
        })]
        
        $Module,
        
        # A list of commands.
        # If this is provided, each command that is a valid extension will be returned.
        [Parameter(ValueFromPipelineByPropertyName)]
        [Management.Automation.CommandInfo[]]
        $Commands,
        # The suffix to apply to each named capture.
        # Defaults to '_Command'
        [Parameter(ValueFromPipelineByPropertyName)]
        [string]
        $Suffix = '_Command',
        # The prefix to apply to each named capture. 
        [Parameter(ValueFromPipelineByPropertyName)]
        [string]
        $Prefix,
        # The file path(s).  If provided, will look for commands within these paths.
        [Parameter(ValueFromPipelineByPropertyName)]
        [Alias('Fullname')]    
        $FilePath,
        # The PowerShell command type.  If this is provided, will only get commands of this type.
        [Parameter(ValueFromPipelineByPropertyName)]
        [Management.Automation.CommandTypes]
        $CommandType,
        # The base PSTypeName(s).
        # If provided, any commands that match the pattern will apply these typenames, too.
        [string[]]
        $PSTypeName
        )
        process {        
            if ($Module -is [string]) {
                $Module = Get-Module $Module
            }
            $ModuleInfo = $module
            if (-not $ModuleInfo) { return }
            
            $ModuleCommandPattern = # Aspect.ModuleExtensionPattern
                                    &amp; { 
                                        &lt;#
                                        .SYNOPSIS
                                            Outputs a module's extension pattern
                                        .DESCRIPTION
                                            Outputs a regular expression that will match any possible pattern.
                                        .EXAMPLE
                                            Aspect.ModuleCommandPattern -Module PipeScript # Should -BeOfType ([Regex])
                                        #&gt;
                                        [Alias('Aspect.ModuleCommandPattern')]
                                        param(
                                        # The name of a module, or a module info object.
                                        [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
                                        [ValidateScript({
                                        $validTypeList = [System.String],[System.Management.Automation.PSModuleInfo]
                                        $thisType = $_.GetType()
                                        $IsTypeOk =
                                            $(@( foreach ($validType in $validTypeList) {
                                                if ($_ -as $validType) {
                                                    $true;break
                                                }
                                            }))
                                        if (-not $isTypeOk) {
                                            throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','psmoduleinfo'."
                                        }
                                        return $true
                                        })]
                                        
                                        $Module,
                                        # The suffix to apply to each named capture.
                                        # Defaults to '_Command'
                                        [Parameter(ValueFromPipelineByPropertyName)]
                                        [string]
                                        $Suffix = '_Command',
                                        # The prefix to apply to each named capture. 
                                        [Parameter(ValueFromPipelineByPropertyName)]
                                        [string]
                                        $Prefix
                                        )
                                        process {
                                            if ($Module -is [string]) {
                                                $Module = Get-Module $Module
                                            }
                                            $ModuleInfo = $module
                                            #region Search for Module Extension Types
                                            if (-not $ModuleInfo) { return }
                                            $ModuleExtensionTypes = # Aspect.ModuleExtensionTypes
                                                                    &amp; { 
                                                                        &lt;#
                                                                        .SYNOPSIS
                                                                            Outputs a module's extension types
                                                                        .DESCRIPTION
                                                                            Outputs the extension types defined in a module's manifest.
                                                                        .EXAMPLE
                                                                            # Outputs a PSObject with information about extension command types.
                                                                            
                                                                            # The two primary pieces of information are the `.Name` and `.Pattern`.
                                                                            Aspect.ModuleExtensionType -Module PipeScript # Should -BeOfType ([PSObject])
                                                                        #&gt;
                                                                        [Alias('Aspect.ModuleCommandTypes','Aspect.ModuleCommandType','Aspect.ModuleExtensionTypes')]
                                                                        param(
                                                                        # The name of a module, or a module info object.
                                                                        [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
                                                                        [ValidateScript({
                                                                        $validTypeList = [System.String],[System.Management.Automation.PSModuleInfo]
                                                                        $thisType = $_.GetType()
                                                                        $IsTypeOk =
                                                                            $(@( foreach ($validType in $validTypeList) {
                                                                                if ($_ -as $validType) {
                                                                                    $true;break
                                                                                }
                                                                            }))
                                                                        if (-not $isTypeOk) {
                                                                            throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','psmoduleinfo'."
                                                                        }
                                                                        return $true
                                                                        })]
                                                                        
                                                                        $Module
                                                                        )
                                                                        begin {
                                                                            $ExtensionCollectionNames = 
                                                                                "Extension", "Command", "Cmdlet", "Function", "Alias", "Script", "Application", "File","Configuration"
                                                                            $ExtensionCollectionNames = @($ExtensionCollectionNames -replace '.+$','${0}Type') + @($ExtensionCollectionNames -replace '.+$','${0}Types')
                                                                        }
                                                                        process {
                                                                            #region Resolve Module Info
                                                                            if ($Module -is [string]) {
                                                                                $Module = Get-Module $Module
                                                                            }
                                                                            $ModuleInfo = $module                
                                                                            if (-not $ModuleInfo) { return }
                                                                            #endregion Resolve Module Info
                                                                            #region Check Cache and Hopefully Return
                                                                            if (-not $script:ModuleExtensionTypeCache) {
                                                                                $script:ModuleExtensionTypeCache = @{}
                                                                            }
                                                                            
                                                                            if ($script:ModuleExtensionTypeCache[$ModuleInfo]) {
                                                                                return $script:ModuleExtensionTypeCache[$ModuleInfo]
                                                                            }
                                                                            #endregion Check Cache and Hopefully Return
                                                                            #region Find Extension Types
                                                                            $modulePrivateData  = $ModuleInfo.PrivateData
                                                                            $SortedExtensionTypes = [Ordered]@{}
                                                                            foreach ($TypeOfExtensionCollection in $ExtensionCollectionNames) {
                                                                                $moduleExtensionTypes = 
                                                                                    if ($modulePrivateData.$TypeOfExtensionCollection) {
                                                                                        $modulePrivateData.$TypeOfExtensionCollection
                                                                                    } elseif ($modulePrivateData.PSData.$TypeOfExtensionCollection) {
                                                                                        $modulePrivateData.PSData.$TypeOfExtensionCollection
                                                                                    } else {
                                                                                        $null
                                                                                    }
                                                                                if (-not $moduleExtensionTypes) { continue } 
                                                                                foreach ($commandType in @($ModuleExtensionTypes.GetEnumerator() | Sort-Object Key)) {
                                                                                    if ($commandType.Value -is [Collections.IDictionary]) {
                                                                                        if (-not $commandType.Value.Name) {
                                                                                            $commandType.Value["Name"] = $commandType.Key
                                                                                        }
                                                                                        if (-not $commandType.Value.PSTypeName) {
                                                                                            $commandType.Value["PSTypeName"] = "$($module.Name).ExtensionCommandType"
                                                                                        }
                                                                                        $SortedExtensionTypes[$commandType.Name] = $commandType.Value
                                                                                    } else {
                                                                                        $SortedExtensionTypes[$commandType.Name] = [Ordered]@{
                                                                                            PSTypeName = "$($module.Name).ExtensionCommandType"
                                                                                            Name    = $commandType.Key
                                                                                            Pattern = $commandType.Value
                                                                                        }
                                                                                    }
                                                                                    if ($TypeOfExtensionCollection -notmatch '(?&gt;Extension|Command|Cmdlet)') {
                                                                                        $SortedExtensionTypes[$commandType.Name].CommandType = $TypeOfExtensionCollection -replace 'Type(?:s)?$'
                                                                                    } elseif ($TypeOfExtensionCollection -match 'Cmdlet') {
                                                                                        $SortedExtensionTypes[$commandType.Name].CommandType = "(?&gt;Alias|Function|Filter|Cmdlet)"
                                                                                    }
                                                                                }
                                                                            }
                                                                            
                                                                            $SortedExtensionTypes.PSTypeName="$($Module.Name).ExtensionCommandTypes"
                                                                            
                                                                            $script:ModuleExtensionTypeCache[$ModuleInfo] = [PSCustomObject]$SortedExtensionTypes
                                                                            $script:ModuleExtensionTypeCache[$ModuleInfo]
                                                                            #endregion Find Extension Types
                                                                        }    
                                                                     } -Module $moduleInfo
                                            
                                            if (-not $ModuleExtensionTypes) { return }
                                                
                                            # With some clever understanding of Regular expressions, we can make match any/all of our potential command types.
                                            # Essentially: Regular Expressions can look ahead (matching without changing the position), and be optional.
                                            # So we can say "any/all" by making a series of optional lookaheads.
                                            
                                            # We'll go thru each pattern in order
                                            $combinedRegex = @(foreach ($categoryExtensionTypeInfo in @($ModuleExtensionTypes.psobject.properties)) {
                                                $categoryPattern = $categoryExtensionTypeInfo.Value.Pattern                
                                                # ( and skip anyone that does not have a pattern)
                                                if (-not $categoryPattern) { continue } 
                                                '(?=' + # Start a lookahead
                                                    '.{0,}' + # match any or no characters
                                                    # followed by the command pattern
                                                    "(?&lt;$Prefix$($categoryExtensionTypeInfo.Name -replace '\p{P}', '_')$Suffix&gt;$categoryPattern)" +
                                                    ')?' # made optional                            
                                            }) -join [Environment]::NewLine
                                            # Now that we've combined the whole thing, make it a Regex and output it.        
                                            [Regex]::new("$combinedRegex", 'IgnoreCase,IgnorePatternWhitespace','00:00:01')
                                        }
                                     } $ModuleInfo -Prefix $prefix -Suffix $Suffix
            $ModuleCommandTypes   = # Aspect.ModuleExtensionType
                                    &amp; { 
                                        &lt;#
                                        .SYNOPSIS
                                            Outputs a module's extension types
                                        .DESCRIPTION
                                            Outputs the extension types defined in a module's manifest.
                                        .EXAMPLE
                                            # Outputs a PSObject with information about extension command types.
                                            
                                            # The two primary pieces of information are the `.Name` and `.Pattern`.
                                            Aspect.ModuleExtensionType -Module PipeScript # Should -BeOfType ([PSObject])
                                        #&gt;
                                        [Alias('Aspect.ModuleCommandTypes','Aspect.ModuleCommandType','Aspect.ModuleExtensionTypes')]
                                        param(
                                        # The name of a module, or a module info object.
                                        [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
                                        [ValidateScript({
                                        $validTypeList = [System.String],[System.Management.Automation.PSModuleInfo]
                                        $thisType = $_.GetType()
                                        $IsTypeOk =
                                            $(@( foreach ($validType in $validTypeList) {
                                                if ($_ -as $validType) {
                                                    $true;break
                                                }
                                            }))
                                        if (-not $isTypeOk) {
                                            throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','psmoduleinfo'."
                                        }
                                        return $true
                                        })]
                                        
                                        $Module
                                        )
                                        begin {
                                            $ExtensionCollectionNames = 
                                                "Extension", "Command", "Cmdlet", "Function", "Alias", "Script", "Application", "File","Configuration"
                                            $ExtensionCollectionNames = @($ExtensionCollectionNames -replace '.+$','${0}Type') + @($ExtensionCollectionNames -replace '.+$','${0}Types')
                                        }
                                        process {
                                            #region Resolve Module Info
                                            if ($Module -is [string]) {
                                                $Module = Get-Module $Module
                                            }
                                            $ModuleInfo = $module                
                                            if (-not $ModuleInfo) { return }
                                            #endregion Resolve Module Info
                                            #region Check Cache and Hopefully Return
                                            if (-not $script:ModuleExtensionTypeCache) {
                                                $script:ModuleExtensionTypeCache = @{}
                                            }
                                            
                                            if ($script:ModuleExtensionTypeCache[$ModuleInfo]) {
                                                return $script:ModuleExtensionTypeCache[$ModuleInfo]
                                            }
                                            #endregion Check Cache and Hopefully Return
                                            #region Find Extension Types
                                            $modulePrivateData  = $ModuleInfo.PrivateData
                                            $SortedExtensionTypes = [Ordered]@{}
                                            foreach ($TypeOfExtensionCollection in $ExtensionCollectionNames) {
                                                $moduleExtensionTypes = 
                                                    if ($modulePrivateData.$TypeOfExtensionCollection) {
                                                        $modulePrivateData.$TypeOfExtensionCollection
                                                    } elseif ($modulePrivateData.PSData.$TypeOfExtensionCollection) {
                                                        $modulePrivateData.PSData.$TypeOfExtensionCollection
                                                    } else {
                                                        $null
                                                    }
                                                if (-not $moduleExtensionTypes) { continue } 
                                                foreach ($commandType in @($ModuleExtensionTypes.GetEnumerator() | Sort-Object Key)) {
                                                    if ($commandType.Value -is [Collections.IDictionary]) {
                                                        if (-not $commandType.Value.Name) {
                                                            $commandType.Value["Name"] = $commandType.Key
                                                        }
                                                        if (-not $commandType.Value.PSTypeName) {
                                                            $commandType.Value["PSTypeName"] = "$($module.Name).ExtensionCommandType"
                                                        }
                                                        $SortedExtensionTypes[$commandType.Name] = $commandType.Value
                                                    } else {
                                                        $SortedExtensionTypes[$commandType.Name] = [Ordered]@{
                                                            PSTypeName = "$($module.Name).ExtensionCommandType"
                                                            Name    = $commandType.Key
                                                            Pattern = $commandType.Value
                                                        }
                                                    }
                                                    if ($TypeOfExtensionCollection -notmatch '(?&gt;Extension|Command|Cmdlet)') {
                                                        $SortedExtensionTypes[$commandType.Name].CommandType = $TypeOfExtensionCollection -replace 'Type(?:s)?$'
                                                    } elseif ($TypeOfExtensionCollection -match 'Cmdlet') {
                                                        $SortedExtensionTypes[$commandType.Name].CommandType = "(?&gt;Alias|Function|Filter|Cmdlet)"
                                                    }
                                                }
                                            }
                                            
                                            $SortedExtensionTypes.PSTypeName="$($Module.Name).ExtensionCommandTypes"
                                            
                                            $script:ModuleExtensionTypeCache[$ModuleInfo] = [PSCustomObject]$SortedExtensionTypes
                                            $script:ModuleExtensionTypeCache[$ModuleInfo]
                                            #endregion Find Extension Types
                                        }    
                                     } $ModuleInfo
            
            $commands    =
                @(
                if ($PSBoundParameters['Commands']) {
                    $commands
                }
                elseif ($PSBoundParameters['FilePath']) {
                    if (-not $commandType) {
                        $commandType = 'Application,ExternalScript'
                    }
                    foreach ($file in Get-ChildItem -File -Path $PSBoundParameters['FilePath'] -Recurse) {
                        $ExecutionContext.SessionState.InvokeCommand.GetCommand($file.FullName, $commandType)
                    }
                } else {
                    if (-not $CommandType) {
                        $commandType = 'Function,Alias,Filter,Cmdlet'
                    }
                    $ExecutionContext.SessionState.InvokeCommand.GetCommands('*', $commandType, $true)
                })
            :nextCommand foreach ($cmd in $commands) {            
                $matched = $ModuleCommandPattern.Match("$cmd")
                if (-not $matched.Success) { continue }
                $NamedGroupMatch = $false
                :nextCommandType foreach ($group in $matched.Groups) {
                    if (-not $group.Success) { continue }
                    if ($null -ne ($group.Name -as [int])) { continue }                
                    $CommandTypeName     = $group.Name.Replace('_','.')
                    $ThisCommandsType    = $ModuleCommandTypes.($group.Name -replace "^$prefix" -replace "$suffix$")
                    if ($ThisCommandsType) {
                        $ThisTypeFilter = @($ThisCommandsType.CommandType,$ThisCommandsType.CommandTypes -ne $null)[0]
                        if ($ThisTypeFilter -and ($cmd.CommandType -notmatch $ThisTypeFilter)) {
                            continue nextCommandType
                        }
                        $ThisExcludeFilter = @($ThisCommandsType.ExcludeCommandType,$ThisCommandsType.ExcludeCommandTypes -ne $null)[0]
                        if ($ThisExcludeFilter -and ($cmd.CommandType -match $ThisExcludeFilter)) {
                            continue nextCommandType
                        }
                    }
                    $NamedGroupMatch     = $true
                    if ($PSTypeName) {
                        foreach ($psuedoType in $PSTypeName) {
                            if ($cmd.pstypenames -notcontains $psuedoType) {
                                $cmd.pstypenames.insert(0, $psuedoType)        
                            }
                        }
                    }
                    if ($cmd.pstypenames -notcontains $CommandTypeName) {
                        $cmd.pstypenames.insert(0, $CommandTypeName)
                    }
                }
                if ($NamedGroupMatch) {
                    $cmd
                }
            }
        }
     } -Module $module @Splat
}

                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>AliasCount</Name>
        <GetScriptBlock>
                        @($this.Alias).Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ApplicationCount</Name>
        <GetScriptBlock>
                        @($this.Application).Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>CmdletCount</Name>
        <GetScriptBlock>
                        @($this.Alias).Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Count</Name>
        <GetScriptBlock>
                        @($this.All).Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Extended</Name>
        <GetScriptBlock>
                        $this.FindExtensions()

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>FunctionCount</Name>
        <GetScriptBlock>
                        @($this.Function).Count
                    </GetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>DefaultDisplay</Name>
        <Value>Count
AliasCount
ApplicationCount
CmdletCount
FunctionCount</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Errors</Name>
    <Members>
      <ScriptMethod>
        <Name>LineLike</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Filters errors by line wildcard
.DESCRIPTION
    Filters entries in $Error for items that a .Line like a wildcard.
.EXAMPLE
    $error.LineLike("Get-*")
#&gt;
param(
# A wildcard pattern.
[string]
$Like
)

,@(foreach ($err in $this) {
    if ($err.InvocationInfo.Line -like $Like) {
        $err
    }
})
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>LineMatch</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Filters errors by command pattern
.DESCRIPTION
    Filters entries in $Error for items that have a .CommandLine matching the pattern.
.EXAMPLE
    $error.LineMatc("^Get")
#&gt;
param(
# A regular expression.
$Match
)

,@(foreach ($err in $this) {
    if ($err.InvocationInfo.Line -match $match) {
        $err
    }
})
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>ByLine</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets errors by line
.DESCRIPTION
    Gets all lines that produced errors
.EXAMPLE
    $error.ByLine    
#&gt;
$errorsByLine = 
    [Collections.Generic.Dictionary[
        string,
        [Collections.Generic.List[psobject]]
    ]]::new([System.StringComparer]::OrdinalIgnoreCase)


foreach ($err in $this) {
    
    $errLine = $err.InvocationInfo.Line
    if (-not $errLine) { continue }
    if (-not $errorsByLine[$errLine]) {
        $errorsByLine[$errLine] = [Collections.Generic.List[psobject]]::new()
    }
    $null = $errorsByLine[$errLine].Add($err)
}
$errorsByLine

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ByType</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Errors By Type
.DESCRIPTION
    Returns all errors, by type of error.
.EXAMPLE
    $posh.Errors.ByType
#&gt;
$errorsByType = 
    [Collections.Generic.Dictionary[
        type,
        [Collections.Generic.List[psobject]]
    ]]::new()


foreach ($err in $this) {
    
    $exceptionType = if ($err.Exception) {
        $err.Exception.GetType()
    } else {
        $err.GetType()
    }
    if (-not $errorsByType[$exceptionType]) {
        $errorsByType[$exceptionType] = [Collections.Generic.List[psobject]]::new()
    }
    $null = $errorsByType[$exceptionType].Add($err)
}
$errorsByType

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>History</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Error History
.DESCRIPTION
    Gets the history items associated with PowerShell Errors
.EXAMPLE
    $Error.History
#&gt;
$historyIDS = @(foreach ($err in $this) {
    if ($err.InvocationInfo.HistoryId -gt 0) {
        $err.InvocationInfo.HistoryId
    }
})

Get-History -Id $historyIDS
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.ExtensionCollection</Name>
    <Members>
      <ScriptProperty>
        <Name>All</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets all items in an extension collection.
.DESCRIPTION
    Gets all items in a collection of extended commands.
#&gt;
if (-not $this.'.Cache') {
    if (-not $this.'.Module') { return @() }

    $findExtensionArgs  = @($this.'.Module') + @($this.'.Path')
    $allExtensionsFound = 
        @(:nextExtension 
            foreach ($foundExtension in 
                $posh.Commands.FindExtensions.Invoke($findExtensionArgs)
            ) 
            {
            if ($this.'.CommandType') {
                foreach ($typename in $this.'.CommandType') {
                    if ($foundExtension.pstypenames -contains $typename) {
                        $foundExtension
                        continue nextExtension
                    }
                }
            } else {
                $foundExtension
            }
            }
        )
    $this |
        Add-Member NoteProperty '.Cache' $allExtensionsFound -Force
}

return $this.'.Cache'
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>CommandType</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets an extension collection's CommandType
.DESCRIPTION
    Gets the extended CommandTypes(s) that are stored in an extension collection.

    CommandTypes can be defined in a module's manifest.
#&gt;
return $this.'.CommandType'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets an extension collection's command type
.DESCRIPTION
    Sets the extended command types in an extension collection.
#&gt;
param(
# The path.  If this is empty all extended commands will be present in the collection
[string[]]
$CommandType
)

Add-Member -InputObject $this -MemberType NoteProperty -Name '.CommandType' -Value $CommandType -Force
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Module</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets an extension collection's module
.DESCRIPTION
    Gets the module that defines extended types in an extension collection.
#&gt;
return $this.'.Module'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets an extension collection's module
.DESCRIPTION
    Sets the module that defines extended command types in an extension collection.
#&gt;
param(
# The module.
[Management.Automation.PSModuleInfo]
$Module
)

Add-Member -InputObject $this -MemberType NoteProperty -Name '.Module' -Value $module -Force
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Path</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets an extension collection's Path
.DESCRIPTION
    Gets the Path(s) that store extensions in an extension collection.        
#&gt;
return $this.'.Path'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets an extension collection's path
.DESCRIPTION
    Sets the path that defines extended command types in an extension collection.
#&gt;
param(
# The path.  If this is empty, only extensions that are functions or aliases will be found.
[string[]]
$Path
)

Add-Member -InputObject $this -MemberType NoteProperty -Name '.Path' -Value $Path -Force
                    </SetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Host</Name>
    <Members>
      <ScriptProperty>
        <Name>Height</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the height of the host
.DESCRIPTION
    Gets the height of the host (in characters).
.EXAMPLE
    $posh.Host.Height
.EXAMPLE
    $Host.Height
#&gt;
$this.UI.RawUI.BufferSize.Height
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Width</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the Width of the host
.DESCRIPTION
    Gets the Width of the host (in characters).
.EXAMPLE
    $posh.Host.Width
.EXAMPLE
    $Host.Width
#&gt;
$this.UI.RawUI.BufferSize.Width
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Input</Name>
    <Members>
      <AliasProperty>
        <Name>After</Name>
        <ReferencedMemberName>Append</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Before</Name>
        <ReferencedMemberName>Prepend</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Undo</Name>
        <ReferencedMemberName>Pop</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Append</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Appends content to a stackable function
.DESCRIPTION

#&gt;
param(
# The value to prepend.
$Value
)

$ToAppend = $this.Stringify($Value)
$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
$this.Current = "@(. { $currentFunction }; . { $toAppend}) -join ''" 
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Clear</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Clears a stackable function
.DESCRIPTION
    Clears a stackable function, resetting it to it's original state.
.EXAMPLE
    $Posh.Prompt.Clear()
#&gt;
if ($this.Stack -and $this.Stack.Count) {
    
    $posh.ExecutionContext.SessionState.psvariable.Set("function:$($this.FunctionName)", @($this.Stack.ToArray())[-1])     
    $this.Stack.Clear()
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Pop</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pops the last value from a function stack
.DESCRIPTION
    Pops the latest value from a function stack, such as the prompt.
.EXAMPLE
    $Posh.Prompt.Pop()
#&gt;
param(
  
)

if ($this.Stack -and $this.Stack.Count) {
    $posh.ExecutionContext.SessionState.psvariable.Set("function:$($this.FunctionName)", $this.Stack.Pop()) 
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Prepend</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Prepends content to a stackable function.
.DESCRIPTION
    Prepends content to a stackable function.

    This takes the current entry and adds content to it's beginning.
#&gt;
param(
# The value to prepend.
$Value
)



$toPrepend = $this.Stringify($Value)
$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
$this.Current = "@(. { $toPrepend} ; . { $currentFunction }) -join ''" 
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Push</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pushes an entry into a stackable function
.DESCRIPTION
    Pushes an entry into a stackable function.

    This overwrites the existing entry,
    and adds the previous value to the stack so it can be easily undone.
#&gt;
param(
# The new value for the function
[ScriptBlock]
$Value
)

$this.Current = $Value
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Replace</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Replaces content within a function
.DESCRIPTION
    Replaces content within a stackable function, such as the prompt.
.EXAMPLE
    # Replace both ends of the prompt
    $Posh.Prompt.Replace('PS ', 0x27d6,$true).Replace('&gt;', 0x27d5, $true)
.EXAMPLE
    $Posh.Prompt.Replace($(
        if ($env:User) {
            $env:User
        } elseif ($env:UserName) {
            $env:UserName
        }
    ),'***')
#&gt;
param(
# The content to replace
$Replace,

# The new value
$Value
)


$toReplace = if ($Value -is [ScriptBlock]) {
    "{$Value}"
} else {
    $this.Stringify($Value)
}

$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")

$replaceRegex = "[Regex]::new('$($Replace -replace "'","''")','IgnoreCase,IgnorePatternWhitespace','00:00:02')"
$passThru = $false
foreach ($arg in $args) {
    if ($arg -is [bool] -and $arg) {
        $passThru = $true
    }
}
$newFunc = "@(
    `$existingOutput =. { $currentFunction };
    `$replacePattern = $replaceRegex
    `$replaceWith = $toReplace 
    `$replacePattern.Replace(`$existingOutput, `$replaceWith)
) -join ''" 


$this.Current = $newFunc
if ($passThru) {
    $this
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Stringify</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Converts into a stringified value
.DESCRIPTION
    Converts an item into a stringified value.

    This is used internally by stackable functions when they are prepending or appending.
#&gt;
param(
$Prompt
)



if ($Prompt -is [ScriptBlock]) {
    ". {$prompt}"
} else {
    "'$(
        $(
    if ($Prompt -is [int]) {
        if ($Prompt -le 1000) {
            $Prompt -as [char] -as [string]
        } else {
            $ExecutionContext.SessionState.InvokeCommand.ExpandString('`u{'+("{0:x}" -f $Prompt)  + '}')
        }
    } else {
        $Prompt
    }
        ) -replace "'","''"
    )'"
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Current</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the value of a stackable function
.DESCRIPTION
    Gets the current value of a stackable function.
.EXAMPLE
    $posh.Prompt.Current
#&gt;
$posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the current implementation of a function
.DESCRIPTION
    Sets the current imlementation of a stackable function.

    Stackable functions keep a stack of all prior entries for easy undo.
.EXAMPLE
    $Posh.Prompt.Current = {"?"}
#&gt;
if (-not $this.FunctionName) { return }
$currentFunctionValue = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
$this.Stack.Push(
$currentFunctionValue
)
$posh.ExecutionContext.SessionState.PSVariable.Set("function:$($this.FunctionName)", "$args")
                    </SetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>README</Name>
        <Value>PowerShell has a robust input system.

There's a very useful module by the name of PSReadLine that helps handle advanced input.

Posh allows you to override the input function for PowerShell in a safe, stackable way.

Pipe `$posh.Input` into `Get-Member` to see what it can do.</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Parameters</Name>
    <Members>
      <ScriptMethod>
        <Name>Clear</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Clears default parameter values.
.DESCRIPTION
    Clears all default parameter values.
.EXAMPLE
    $posh.Parameters.Clear()
#&gt;
$global:PSDefaultParameterValues.Clear()
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Remove</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Removes parameter default values.
.DESCRIPTION
    Removes the default values for a command.
.EXAMPLE
    $Posh.Parameters.Remove("Out-Default")
#&gt;
param(
# The name of the command.
$Command,

# The command parameters.
# If this is a dictionary, each value will be used.
# Otherwise, this will be treated as the name of the parameter.
$Parameter
)

$DefaultValueKey =
    if ($command -is [Management.Automation.CommandInfo]) {
        if ($command.Source) {
            $command.Source
        } else {
            $command.Name
        }        
    }
    else {
        "$command"
    }

if ($Parameter -is [Collections.IDictionary]) {
    foreach ($parameterKeyValue in $Parameter.GetEnumerator()) {
        $null = $global:PSDefaultParameterValues.Remove("${defaultValueKey}:$($parameterKeyValue.Key)")
    }
} elseif ($Parameter) {
    $null = $global:PSDefaultParameterValues["${defaultValueKey}:$Parameter"] = $DefaultValue
} else {
    $toRemoveKeys = $global:PSDefaultParameterValues.Keys -like "${defaultValueKey}:*"
    foreach ($toRemove in $toRemoveKeys) {
        $null = $global:PSDefaultParameterValues.Remove($toRemove)
    }
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>SetDefault</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Sets parameter default values.
.DESCRIPTION
    Sets the default value for a parameter.
.EXAMPLE
    $Posh.Parameters.SetDefault("Out-Default", "OutVariable", 'LastOutput')
#&gt;
param(
# The name of the command.
$Command,

# The command parameters.
# If this is a dictionary, each value will be used.
# Otherwise, this will be treated as the name of the parameter.
$Parameter,

# The default value.
$DefaultValue
)

$DefaultValueKey =
    if ($command -is [Management.Automation.CommandInfo]) {
        if ($command.Source) {
            $command.Source
        } else {
            $command.Name
        }        
    }
    else {
        "$command"
    }

if ($Parameter -is [Collections.IDictionary]) {
    foreach ($parameterKeyValue in $Parameter.GetEnumerator()) {
        $global:PSDefaultParameterValues["${defaultValueKey}:$($parameterKeyValue.Key)"] = 
            $parameterKeyValue.Value
    }
} else {
    $global:PSDefaultParameterValues["${defaultValueKey}:$Parameter"] = $DefaultValue
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Defaults</Name>
        <GetScriptBlock>
                        $defaultsByCommand = [Ordered]@{}
foreach ($key in $global:PSDefaultParameterValues.Keys) {
    $commandName, $parameterName = $key -split ':',2
    if (-not $defaultsByCommand[$commandName]) {
        $defaultsByCommand[$commandName] = [Ordered]@{}
    }
    $defaultsByCommand[$commandName][$parameterName] = $global:PSDefaultParameterValues[$key]
}
$defaultsByCommand
                    </GetScriptBlock>
        <SetScriptBlock>
                        $argArray = @(
    foreach ($arg in $args) {
        $arg
    }
)
$this.SetDefault.Invoke($argArray)

                    </SetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>README</Name>
        <Value>One of the strengths of PowerShell is how it treats parameters.

You can find metadata about any command's parameters.

You can also provide default values for any command's parameters.

`$Posh.Parameters` helps you Find PowerShell parameters and manage their default values.</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Profiles</Name>
    <Members>
      <ScriptMethod>
        <Name>Add</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Adds content to a profile
.DESCRIPTION
    Adds content to a PowerShell profile
#&gt;
param(
# The content to add to your profile.
[ScriptBlock]
$Content,

# Which profile should the content be added to?
# The default is the current user's current host.
[ValidateSet('AllUsersAllHosts','AllUsersCurrentHosts','CurrentUserAllHosts','CurrentUserCurrentHost')]
[string]
$WhichProfile = 'CurrentUserCurrentHost'
)

$profilePath = $PROFILE.$WhichProfile

$profileContent = 
    if (Test-Path $profilePath) {
        Get-Content -Raw $profilePath 
    } else {
        ''
    }

if ($profileContent -like "*$Content*") {
    return
}

$profileContent += [Environment]::NewLine
$profileContent += "$content"
$profileContent | Set-Content -Path $profilePath -PassThru



                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ImportModule</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Imports a module in a profile
.DESCRIPTION
    Adds code to import a module in your profile.
    This will ensure the module is loaded whenever you're running PowerShell.
.EXAMPLE
    $Posh.Profile.ImportModule("Posh")
#&gt;
param(
# The name of the module to import.
[string]
$Module,

# Which profile should the content be added to?
# The default is the current user's current host.
[ValidateSet('AllUsersAllHosts','AllUsersCurrentHosts','CurrentUserAllHosts','CurrentUserCurrentHost')]
[string]
$WhichProfile = 'CurrentUserCurrentHost'
)


$AlreadyAdded = $this.Matches("Import-Module $Module", $WhichProfile)
if (-not $AlreadyAdded) {
    $this.Add(
        [scriptblock]::Create("Import-Module $module -Force$([Environment]::Newline)"),
        $WhichProfile
    )
}

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Matches</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Matches patterns within profiles
.DESCRIPTION
    Matches a pattern within profile files.
    
    All places the pattern is found will be returned.
.EXAMPLE
    $Posh.Profile.Matches("Posh")
#&gt;
param(
# The pattern to match.
[regex]
$Pattern,

# Which profile should the content be removed from?
# The default is the current user's current host.
[ValidateSet('AllUsersAllHosts','AllUsersCurrentHosts','CurrentUserAllHosts','CurrentUserCurrentHost')]
[string[]]
$WhichProfile = 'CurrentUserCurrentHost'
)

@(foreach ($prof in $WhichProfile) {
    if (Test-Path ($profile.$prof)) {
        $pattern.Matches((Get-Content -Raw ($profile.$prof)))
    } 
})
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>New</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Creates a new profile
.DESCRIPTION
    Creates a new profile, or returns an existing profile.
.EXAMPLE
    $Posh.Profile.New()
#&gt;
param(
# Which profile should be created?
# The default is the current user's current host.
[ValidateSet('AllUsersAllHosts','AllUsersCurrentHosts','CurrentUserAllHosts','CurrentUserCurrentHost')]
[string]
$WhichProfile = 'CurrentUserCurrentHost'
)

$profilePath = $PROFILE.$WhichProfile

if (Test-Path -LiteralPath $profilePath) {
    Get-Item -LiteralPath $profilePath
} else {
    New-Item -ItemType File -Path $profilePath -Force
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Remove</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Removes content from a profile
.DESCRIPTION
    Removes content from a PowerShell profile.
#&gt;
param(
# The content to remove.
# If the content is a regular expression pattern, any matches will be removed.
# Otherwise, any case-insensitive occurances of the string will be removed.
$Content,

# Which profile should the content be removed from?
# The default is the current user's current host.
[ValidateSet('AllUsersAllHosts','AllUsersCurrentHosts','CurrentUserAllHosts','CurrentUserCurrentHost')]
[string]
$WhichProfile = 'CurrentUserCurrentHost'
)

$this.Replace($Content, '', $WhichProfile)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>RemoveModule</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Remove a module from a profile
.DESCRIPTION
    Remove code that imports a module in your profile.
.EXAMPLE
    $Posh.Profile.RemoveModule("Posh")
#&gt;
param(    
# The name of the module to no longer import.
[string]
$Module,    

# Which profile should the content be added to?
# The default is the current user's current host.
[ValidateSet('AllUsersAllHosts','AllUsersCurrentHosts','CurrentUserAllHosts','CurrentUserCurrentHost')]
[string]
$WhichProfile = 'CurrentUserCurrentHost'
)


$AlreadyAdded = $this.Matches("Import-Module $Module", $WhichProfile)
if ($AlreadyAdded) {
    $this.Remove("Import-Module $Module", $WhichProfile)
}

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Replace</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Replaces content in a profile
.DESCRIPTION
    Replaces content in a PowerShell profile.
#&gt;
param(
# The content to replace.
# If the content is a regular expression pattern, any matches will be replaced.
# Otherwise, any case-insensitive occurances of the string will be replaced.
$Content,

# The content to replace.
# If content replaced was a regular expression,
# this will be treated as a [Regular Expression substitution](https://learn.microsoft.com/en-us/dotnet/standard/base-types/substitutions-in-regular-expressions).
$Replacement = '',

# Which profile should the content be removed from?
# The default is the current user's current host.
[ValidateSet('AllUsersAllHosts','AllUsersCurrentHosts','CurrentUserAllHosts','CurrentUserCurrentHost')]
[string]
$WhichProfile = 'CurrentUserCurrentHost'
)

$profilePath = $PROFILE.$WhichProfile

$profileContent = 
    if (Test-Path $profilePath) {
        Get-Content -Raw $profilePath 
    } else {
        ''
    }

if ($Content -is [regex]) {
    $profileContent = $Content.Replace($profileContent, $Replacement)
} else {
    $Content = "$content"
    if ($Content) {
        $profileContent = 
            $profileContent.Replace(
                $content, $Replacement, [StringComparison]::OrdinalIgnoreCase
            )
    }
}

$profileContent | Set-Content -Path $profilePath -PassThru
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Current</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the current Profile
.DESCRIPTION
    Gets the current PowerShell Profile
.EXAMPLE
    $posh.Profile.Current
#&gt;
"$profile"

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Directory</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the profile directory
.DESCRIPTION
    Gets the PowerShell profile's directory.
.NOTES
    The Profile Directory is a wonderful place to store data.
    ( It is almost always writeable )
.EXAMPLE
    $Profile.Directory
#&gt;
($profile | Split-Path) -as [IO.DirectoryInfo]
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>File</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the profile file
.DESCRIPTION
    Gets the profile file for the current user in the current host.
.EXAMPLE
    $Posh.Profile.File    
#&gt;
if (Test-Path "$profile") {
    Get-Item -LiteralPath "$profile"
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Files</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the profile files
.DESCRIPTION
    Gets the FileInfo objects for each profile that exists.
.EXAMPLE
    $posh.Profile.Files
#&gt;
foreach ($potentialPath in $profile.CurrentUserCurrentHost, $profile.CurrentUserAllHosts, $profile.AllUsersAllHosts, $profile.AllUsersCurrentHost) {
    if ([IO.File]::Exists($potentialPath)) {
        [IO.FileInfo]$potentialPath
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>README</Name>
        <Value>PowerShell has profiles!

Profiles run whenever PowerShell is loaded.

They're great if there's a module you want to always load, or a variable you always want defined.

To see how to manipulate PowerShell profiles with Posh, use $posh.Profiles | Get-Member</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Prompt</Name>
    <Members>
      <AliasProperty>
        <Name>After</Name>
        <ReferencedMemberName>Append</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Before</Name>
        <ReferencedMemberName>Prepend</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Undo</Name>
        <ReferencedMemberName>Pop</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Append</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Appends content to a stackable function
.DESCRIPTION

#&gt;
param(
# The value to prepend.
$Value
)

$ToAppend = $this.Stringify($Value)
$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
$this.Current = "@(. { $currentFunction }; . { $toAppend}) -join ''" 
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Clear</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Clears a stackable function
.DESCRIPTION
    Clears a stackable function, resetting it to it's original state.
.EXAMPLE
    $Posh.Prompt.Clear()
#&gt;
if ($this.Stack -and $this.Stack.Count) {
    
    $posh.ExecutionContext.SessionState.psvariable.Set("function:$($this.FunctionName)", @($this.Stack.ToArray())[-1])     
    $this.Stack.Clear()
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Pop</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pops the last value from a function stack
.DESCRIPTION
    Pops the latest value from a function stack, such as the prompt.
.EXAMPLE
    $Posh.Prompt.Pop()
#&gt;
param(
  
)

if ($this.Stack -and $this.Stack.Count) {
    $posh.ExecutionContext.SessionState.psvariable.Set("function:$($this.FunctionName)", $this.Stack.Pop()) 
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Prepend</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Prepends content to a stackable function.
.DESCRIPTION
    Prepends content to a stackable function.

    This takes the current entry and adds content to it's beginning.
#&gt;
param(
# The value to prepend.
$Value
)



$toPrepend = $this.Stringify($Value)
$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
$this.Current = "@(. { $toPrepend} ; . { $currentFunction }) -join ''" 
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Push</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pushes an entry into a stackable function
.DESCRIPTION
    Pushes an entry into a stackable function.

    This overwrites the existing entry,
    and adds the previous value to the stack so it can be easily undone.
#&gt;
param(
# The new value for the function
[ScriptBlock]
$Value
)

$this.Current = $Value
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Replace</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Replaces content within a function
.DESCRIPTION
    Replaces content within a stackable function, such as the prompt.
.EXAMPLE
    # Replace both ends of the prompt
    $Posh.Prompt.Replace('PS ', 0x27d6,$true).Replace('&gt;', 0x27d5, $true)
.EXAMPLE
    $Posh.Prompt.Replace($(
        if ($env:User) {
            $env:User
        } elseif ($env:UserName) {
            $env:UserName
        }
    ),'***')
#&gt;
param(
# The content to replace
$Replace,

# The new value
$Value
)


$toReplace = if ($Value -is [ScriptBlock]) {
    "{$Value}"
} else {
    $this.Stringify($Value)
}

$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")

$replaceRegex = "[Regex]::new('$($Replace -replace "'","''")','IgnoreCase,IgnorePatternWhitespace','00:00:02')"
$passThru = $false
foreach ($arg in $args) {
    if ($arg -is [bool] -and $arg) {
        $passThru = $true
    }
}
$newFunc = "@(
    `$existingOutput =. { $currentFunction };
    `$replacePattern = $replaceRegex
    `$replaceWith = $toReplace 
    `$replacePattern.Replace(`$existingOutput, `$replaceWith)
) -join ''" 


$this.Current = $newFunc
if ($passThru) {
    $this
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Stringify</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Converts into a stringified value
.DESCRIPTION
    Converts an item into a stringified value.

    This is used internally by stackable functions when they are prepending or appending.
#&gt;
param(
$Prompt
)



if ($Prompt -is [ScriptBlock]) {
    ". {$prompt}"
} else {
    "'$(
        $(
    if ($Prompt -is [int]) {
        if ($Prompt -le 1000) {
            $Prompt -as [char] -as [string]
        } else {
            $ExecutionContext.SessionState.InvokeCommand.ExpandString('`u{'+("{0:x}" -f $Prompt)  + '}')
        }
    } else {
        $Prompt
    }
        ) -replace "'","''"
    )'"
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Current</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the value of a stackable function
.DESCRIPTION
    Gets the current value of a stackable function.
.EXAMPLE
    $posh.Prompt.Current
#&gt;
$posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the current implementation of a function
.DESCRIPTION
    Sets the current imlementation of a stackable function.

    Stackable functions keep a stack of all prior entries for easy undo.
.EXAMPLE
    $Posh.Prompt.Current = {"?"}
#&gt;
if (-not $this.FunctionName) { return }
$currentFunctionValue = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
$this.Stack.Push(
$currentFunctionValue
)
$posh.ExecutionContext.SessionState.PSVariable.Set("function:$($this.FunctionName)", "$args")
                    </SetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>README</Name>
        <Value>`prompt` is the function that is called before PowerShell prompts for input.

$Posh.Prompt allows you to customize the PowerShell prompt.

Prompts are a cool way to customize your shell.

Pipe $Posh.Prompt to Get-Member to see what it can do.</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Stackable</Name>
    <Members>
      <AliasProperty>
        <Name>After</Name>
        <ReferencedMemberName>Append</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Before</Name>
        <ReferencedMemberName>Prepend</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Undo</Name>
        <ReferencedMemberName>Pop</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Append</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Appends content to a stackable function
.DESCRIPTION

#&gt;
param(
# The value to prepend.
$Value
)

$ToAppend = $this.Stringify($Value)
$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
$this.Current = "@(. { $currentFunction }; . { $toAppend}) -join ''" 
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Clear</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Clears a stackable function
.DESCRIPTION
    Clears a stackable function, resetting it to it's original state.
.EXAMPLE
    $Posh.Prompt.Clear()
#&gt;
if ($this.Stack -and $this.Stack.Count) {
    
    $posh.ExecutionContext.SessionState.psvariable.Set("function:$($this.FunctionName)", @($this.Stack.ToArray())[-1])     
    $this.Stack.Clear()
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Pop</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pops the last value from a function stack
.DESCRIPTION
    Pops the latest value from a function stack, such as the prompt.
.EXAMPLE
    $Posh.Prompt.Pop()
#&gt;
param(
  
)

if ($this.Stack -and $this.Stack.Count) {
    $posh.ExecutionContext.SessionState.psvariable.Set("function:$($this.FunctionName)", $this.Stack.Pop()) 
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Prepend</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Prepends content to a stackable function.
.DESCRIPTION
    Prepends content to a stackable function.

    This takes the current entry and adds content to it's beginning.
#&gt;
param(
# The value to prepend.
$Value
)



$toPrepend = $this.Stringify($Value)
$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
$this.Current = "@(. { $toPrepend} ; . { $currentFunction }) -join ''" 
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Push</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pushes an entry into a stackable function
.DESCRIPTION
    Pushes an entry into a stackable function.

    This overwrites the existing entry,
    and adds the previous value to the stack so it can be easily undone.
#&gt;
param(
# The new value for the function
[ScriptBlock]
$Value
)

$this.Current = $Value
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Replace</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Replaces content within a function
.DESCRIPTION
    Replaces content within a stackable function, such as the prompt.
.EXAMPLE
    # Replace both ends of the prompt
    $Posh.Prompt.Replace('PS ', 0x27d6,$true).Replace('&gt;', 0x27d5, $true)
.EXAMPLE
    $Posh.Prompt.Replace($(
        if ($env:User) {
            $env:User
        } elseif ($env:UserName) {
            $env:UserName
        }
    ),'***')
#&gt;
param(
# The content to replace
$Replace,

# The new value
$Value
)


$toReplace = if ($Value -is [ScriptBlock]) {
    "{$Value}"
} else {
    $this.Stringify($Value)
}

$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")

$replaceRegex = "[Regex]::new('$($Replace -replace "'","''")','IgnoreCase,IgnorePatternWhitespace','00:00:02')"
$passThru = $false
foreach ($arg in $args) {
    if ($arg -is [bool] -and $arg) {
        $passThru = $true
    }
}
$newFunc = "@(
    `$existingOutput =. { $currentFunction };
    `$replacePattern = $replaceRegex
    `$replaceWith = $toReplace 
    `$replacePattern.Replace(`$existingOutput, `$replaceWith)
) -join ''" 


$this.Current = $newFunc
if ($passThru) {
    $this
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Stringify</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Converts into a stringified value
.DESCRIPTION
    Converts an item into a stringified value.

    This is used internally by stackable functions when they are prepending or appending.
#&gt;
param(
$Prompt
)



if ($Prompt -is [ScriptBlock]) {
    ". {$prompt}"
} else {
    "'$(
        $(
    if ($Prompt -is [int]) {
        if ($Prompt -le 1000) {
            $Prompt -as [char] -as [string]
        } else {
            $ExecutionContext.SessionState.InvokeCommand.ExpandString('`u{'+("{0:x}" -f $Prompt)  + '}')
        }
    } else {
        $Prompt
    }
        ) -replace "'","''"
    )'"
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Current</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the value of a stackable function
.DESCRIPTION
    Gets the current value of a stackable function.
.EXAMPLE
    $posh.Prompt.Current
#&gt;
$posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the current implementation of a function
.DESCRIPTION
    Sets the current imlementation of a stackable function.

    Stackable functions keep a stack of all prior entries for easy undo.
.EXAMPLE
    $Posh.Prompt.Current = {"?"}
#&gt;
if (-not $this.FunctionName) { return }
$currentFunctionValue = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
$this.Stack.Push(
$currentFunctionValue
)
$posh.ExecutionContext.SessionState.PSVariable.Set("function:$($this.FunctionName)", "$args")
                    </SetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.Management.Automation.PSModuleInfo</Name>
    <Members>
      <AliasProperty>
        <Name>Demos</Name>
        <ReferencedMemberName>Demo</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Recommendations</Name>
        <ReferencedMemberName>Recommendation</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Screenshots</Name>
        <ReferencedMemberName>Screenshot</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Tests</Name>
        <ReferencedMemberName>Test</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Videos</Name>
        <ReferencedMemberName>Video</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>LinkList</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Returns a link list.
.DESCRIPTION
    Returns a list of links from one or more properties in a module's manifest.
.EXAMPLE
    $posh.LinkList(@(
        $this.PrivateData.Screenshot
        $this.PrivateData.Screenshots
        $this.PrivateData.PSData.Screenshot
        $this.PrivateData.PSData.Screenshots
    ), "Posh.Module.Screenshot")
#&gt;
param(
# One or more inputs to the list.
[PSObject[]]
$InputObject,

[string]
$PSTypeName = 'Posh.Module.Link'
)

filter ToLink {
    if ($_ -is [string]) {
        [PSCustomObject]@{
            PSTypeName = $PSTypeName
            Url        = $_
            Source     = $this
        }
    } elseif ($_ -is [Collections.IDictionary]) {
        $_.GetEnumerator() | Sort-Object Key | . ToLink
    } elseif ($_ -is [Collections.DictionaryEntry]) {
        [PSCustomObject][Ordered]@{
            PSTypeName = $PSTypeName
            Name = $_.key
            Url = $_.Value
            Source = $this
        }
    }
}


$inputObject | . ToLink

                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Demo</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets module demos
.DESCRIPTION
    Gets demo files related to a module.
.EXAMPLE
    $Posh.Demos
.LINK
    https://github.com/StartAutomating/ShowDemo
#&gt;
$this |
    Split-Path |
    Get-ChildItem -Recurse -Filter *.demo.ps1 |
    Select-Object -Unique
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Logo</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Module Logos
.DESCRIPTION
    Lists logos for this module.
.EXAMPLE
    $posh.Logos
#&gt;
$this.LinkList(@(
    $this.PrivateData.Logo
    $this.PrivateData.Logos
    $this.PrivateData.PSData.Logo
    $this.PrivateData.PSData.Logos
    $this.PrivateData.PSData.IconURI
), "Posh.Module.Logo")


                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Recommendation</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Module Recommendations
.DESCRIPTION
    Lists other modules this module recommends.
.EXAMPLE    
    # $Posh.Recommends gets every loaded module's recommendations.
    $posh.Recommends
.EXAMPLE
    $posh.Recommendations
#&gt;
$module = $this

$this.LinkList(@(
    
    $module.PrivateData.Recommends
    $module.PrivateData.Recommend
    $module.PrivateData.Recommendation
    $module.PrivateData.Recommendations

    $module.PrivateData.PSData.Recommends
    $module.PrivateData.PSData.Recommend
    $module.PrivateData.PSData.Recommendation
    $module.PrivateData.PSData.Recommendations
), "Posh.Recommendation")



                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Screenshot</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Module Screenshots
.DESCRIPTION
    Lists screenshots from this module.
.EXAMPLE
    $posh.Screenshots
#&gt;
$this.LinkList(@(
    $this.PrivateData.Screenshot
    $this.PrivateData.Screenshots
    $this.PrivateData.PSData.Screenshot
    $this.PrivateData.PSData.Screenshots
), "Posh.Module.Screenshot")


                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Test</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets module tests
.DESCRIPTION
    Gets Pester Tests located within a module.
#&gt;
$this |
    Split-Path |
    Get-ChildItem -Recurse -Filter *.tests.ps1 |
    Select-Object -Unique
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Video</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Module Videos
.DESCRIPTION
    Lists videos about this module.
.EXAMPLE
    $posh.Videos
#&gt;
$this.LinkList(@(
    $this.PrivateData.Video
    $this.PrivateData.Videos
    $this.PrivateData.PSData.Video
    $this.PrivateData.PSData.Videos
), "Posh.Module.Video")


                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.TimeZoneInfo</Name>
    <Members>
      <ScriptProperty>
        <Name>LocalTime</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the local time
.DESCRIPTION
    Gets the local time for a timezone.
.EXAMPLE
    Get-TimeZone -ListAvailable
.EXAMPLE
    Get-TimeZone | Select LocalTime
#&gt;
[DateTime]::UTCNow + $this.GetUtcOffset([DateTime]::UtcNow)
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
</Types>
